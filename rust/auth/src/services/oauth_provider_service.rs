use crate::entities::oauth_providers;
use crate::error::AuthError;
use crate::services::provider_settings;
#[cfg(feature = "aws-secrets")]
use aws_config;
#[cfg(feature = "aws-secrets")]
use aws_sdk_secretsmanager as sm;
use chrono::Utc;
use sea_orm::{ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter, Set};

pub struct OAuthProviderService;

impl OAuthProviderService {
    pub async fn list(db: &DatabaseConnection) -> Result<Vec<oauth_providers::Model>, AuthError> {
        let items = oauth_providers::Entity::find()
            .all(db)
            .await
            .map_err(|e| AuthError::internal_error(format!("DB error: {}", e)))?;
        Ok(items)
    }

    pub async fn delete_by_provider(
        db: &DatabaseConnection,
        provider: &str,
    ) -> Result<(), AuthError> {
        if let Some(existing) = Self::get_by_provider(db, provider).await? {
            oauth_providers::Entity::delete_by_id(existing.id)
                .exec(db)
                .await
                .map_err(|e| AuthError::internal_error(format!("Failed to delete provider: {}", e)))?;
            return Ok(());
        }

        Err(AuthError::entity_not_found("Provider not found"))
    }

    pub async fn get_by_provider(
        db: &DatabaseConnection,
        provider: &str,
    ) -> Result<Option<oauth_providers::Model>, AuthError> {
        let item = oauth_providers::Entity::find()
            .filter(oauth_providers::Column::ProviderName.eq(provider.to_string()))
            .one(db)
            .await
            .map_err(|e| AuthError::internal_error(format!("DB error: {}", e)))?;
        Ok(item)
    }

    // TODO: refactor - split up into fns
    pub async fn upsert(
        db: &DatabaseConnection,
        provider: &str,
        client_id: &str,
        client_secret: &str,
        auth_url: Option<&str>,
        token_url: Option<&str>,
        userinfo_url: Option<&str>,
    ) -> Result<oauth_providers::Model, AuthError> {
        // Redirect URL is generated at runtime by provider_settings; do not persist or use here

        // For Google, override with constants (ignore user input)
        let (final_auth_url, final_token_url, final_userinfo_url) =
            if provider == provider_settings::PROVIDER_GOOGLE {
                (
                    Some(provider_settings::GOOGLE_AUTH_URL),
                    Some(provider_settings::GOOGLE_TOKEN_URL),
                    Some(provider_settings::GOOGLE_USERINFO_URL),
                )
            } else {
                (auth_url, token_url, userinfo_url)
            };

        // create AWS SM client
        let aws_conf = aws_config::load_from_env().await;
        let sm_client = sm::Client::new(&aws_conf);

        if let Some(existing) = Self::get_by_provider(db, provider).await? {
            // UPDATE path: existing record already has an ID
            let record_id = existing.id;
            let secret_name = format!("mycorner/oauth/{}/{}", provider, record_id);

            // Store/update secret in AWS Secrets Manager
            Self::create_or_update_secret(&sm_client, &secret_name, client_secret).await?;

            // Update DB record with all fields and secret name
            let mut am: oauth_providers::ActiveModel = existing.clone().into();
            am.client_id = Set(client_id.to_string());
            am.client_secret = Set(secret_name.clone()); // store secret name, not plaintext
                                                         // Do not store redirect_url in DB; redirect URL is generated by the API at runtime
            am.auth_url = Set(final_auth_url.map(|s| s.to_string()));
            am.token_url = Set(final_token_url.map(|s| s.to_string()));
            am.userinfo_url = Set(final_userinfo_url.map(|s| s.to_string()));
            am.updated_at = Set(Some(Utc::now().into()));
            let updated = am.update(db).await.map_err(|e| {
                AuthError::internal_error(format!("Failed to update provider: {}", e))
            })?;
            return Ok(updated);
        }

        // INSERT path: save DB record first to get primary key
        let new_record = oauth_providers::ActiveModel {
            provider_name: Set(provider.to_string()),
            client_id: Set(client_id.to_string()),
            client_secret: Set(String::new()), // temporary placeholder
            // Do not persist redirect_url; it's computed at runtime from Config.api_url
            auth_url: Set(final_auth_url.map(|s| s.to_string())),
            token_url: Set(final_token_url.map(|s| s.to_string())),
            userinfo_url: Set(final_userinfo_url.map(|s| s.to_string())),
            created_at: Set(Some(Utc::now().into())),
            updated_at: Set(Some(Utc::now().into())),
            ..Default::default()
        };

        let inserted = new_record
            .insert(db)
            .await
            .map_err(|e| AuthError::internal_error(format!("Failed to insert provider: {}", e)))?;

        let record_id = inserted.id;
        let secret_name = format!("mycorner/oauth/{}/{}", provider, record_id);

        // Create secret in Secrets Manager with unique ID-based name
        if let Err(e) = Self::create_or_update_secret(&sm_client, &secret_name, client_secret).await
        {
            // Cleanup: delete the DB record we just created since secret creation failed
            let _ = oauth_providers::Entity::delete_by_id(record_id)
                .exec(db)
                .await;
            return Err(e);
        }

        // Update DB record with the secret name
        let mut am: oauth_providers::ActiveModel = inserted.into();
        am.client_secret = Set(secret_name);
        let final_record = am.update(db).await.map_err(|e| {
            AuthError::internal_error(format!(
                "Failed to update provider with secret name: {}",
                e
            ))
        })?;

        Ok(final_record)
    }

    /// Helper to create or update a secret in AWS Secrets Manager
    async fn create_or_update_secret(
        sm_client: &sm::Client,
        secret_name: &str,
        secret_value: &str,
    ) -> Result<(), AuthError> {
        // TODO: extract create & update fns

        // Try to update existing secret first. If it doesn't exist, create it.
        let put_res = sm_client
            .put_secret_value()
            .secret_id(secret_name)
            .secret_string(secret_value)
            .send()
            .await;

        match put_res {
            Ok(_) => return Ok(()),
            Err(put_err) => {
                // If the secret wasn't found, attempt to create it. Otherwise return error.
                let put_err_str = format!("{:?}", put_err);
                if put_err_str.contains("ResourceNotFoundException") {
                    let create_res = sm_client
                        .create_secret()
                        .name(secret_name)
                        .secret_string(secret_value)
                        .send()
                        .await;

                    match create_res {
                        Ok(_) => return Ok(()),
                        Err(create_err) => {
                            // If create failed because secret already exists (race), try put again.
                            let create_err_str = format!("{:?}", create_err);
                            if create_err_str.contains("ResourceExistsException") {
                                sm_client
                                    .put_secret_value()
                                    .secret_id(secret_name)
                                    .secret_string(secret_value)
                                    .send()
                                    .await
                                    .map_err(|e| {
                                        AuthError::internal_error(format!(
                                            "Failed to update secret in Secrets Manager after race: {}",
                                            e
                                        ))
                                    })?;
                                return Ok(());
                            }

                            return Err(AuthError::internal_error(format!(
                                "Failed to create secret in Secrets Manager: {}",
                                create_err
                            )));
                        }
                    }
                }

                return Err(AuthError::internal_error(format!(
                    "Failed to update secret in Secrets Manager: {}",
                    put_err
                )));
            }
        }
    }
}
