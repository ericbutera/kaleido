use crate::entities::oauth_providers;
use crate::error::AuthError;
use crate::services::provider_settings;
use crate::secrets_manager;
use chrono::Utc;
use sea_orm::{ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter, Set};

pub struct OAuthProviderService;

impl OAuthProviderService {
    pub async fn list(db: &DatabaseConnection) -> Result<Vec<oauth_providers::Model>, AuthError> {
        let items = oauth_providers::Entity::find()
            .all(db)
            .await
            .map_err(|e| AuthError::internal_error(format!("DB error: {}", e)))?;
        Ok(items)
    }

    pub async fn delete_by_provider(
        db: &DatabaseConnection,
        provider: &str,
    ) -> Result<(), AuthError> {
        if let Some(existing) = Self::get_by_provider(db, provider).await? {
            oauth_providers::Entity::delete_by_id(existing.id)
                .exec(db)
                .await
                .map_err(|e| {
                    AuthError::internal_error(format!("Failed to delete provider: {}", e))
                })?;
            return Ok(());
        }

        Err(AuthError::entity_not_found("Provider not found"))
    }

    pub async fn get_by_provider(
        db: &DatabaseConnection,
        provider: &str,
    ) -> Result<Option<oauth_providers::Model>, AuthError> {
        let item = oauth_providers::Entity::find()
            .filter(oauth_providers::Column::ProviderName.eq(provider.to_string()))
            .one(db)
            .await
            .map_err(|e| AuthError::internal_error(format!("DB error: {}", e)))?;
        Ok(item)
    }

    // TODO: refactor - split up into fns
    pub async fn upsert(
        db: &DatabaseConnection,
        provider: &str,
        client_id: &str,
        client_secret: &str,
        auth_url: Option<&str>,
        token_url: Option<&str>,
        userinfo_url: Option<&str>,
    ) -> Result<oauth_providers::Model, AuthError> {
        // Redirect URL is generated at runtime by provider_settings; do not persist or use here

        // For Google, override with constants (ignore user input)
        let (final_auth_url, final_token_url, final_userinfo_url) =
            if provider == provider_settings::PROVIDER_GOOGLE {
                (
                    Some(provider_settings::GOOGLE_AUTH_URL),
                    Some(provider_settings::GOOGLE_TOKEN_URL),
                    Some(provider_settings::GOOGLE_USERINFO_URL),
                )
            } else {
                (auth_url, token_url, userinfo_url)
            };

        // TODO: abstract provider specific logic (like Google overrides) into separate module/layer so this upsert fn is more generic and reusable for other provider types in the future
        // Create a secrets manager (GCP-backed by default). If none is available an error is returned.
        let sm_client = secrets_manager::create_secrets_manager(None).await?;

        if let Some(existing) = Self::get_by_provider(db, provider).await? {
            // UPDATE path: existing record already has an ID
            let record_id = existing.id;
            let secret_name = format!("mycorner/oauth/{}/{}", provider, record_id);

            // Store/update secret in Secrets Manager
            sm_client.put_secret(&secret_name, client_secret).await?;

            // Update DB record with all fields and secret name
            let mut am: oauth_providers::ActiveModel = existing.clone().into();
            am.client_id = Set(client_id.to_string());
            am.client_secret = Set(secret_name.clone()); // store secret name, not plaintext
                                                         // Do not store redirect_url in DB; redirect URL is generated by the API at runtime
            am.auth_url = Set(final_auth_url.map(|s| s.to_string()));
            am.token_url = Set(final_token_url.map(|s| s.to_string()));
            am.userinfo_url = Set(final_userinfo_url.map(|s| s.to_string()));
            am.updated_at = Set(Some(Utc::now().into()));
            let updated = am.update(db).await.map_err(|e| {
                AuthError::internal_error(format!("Failed to update provider: {}", e))
            })?;
            return Ok(updated);
        }

        // INSERT path: save DB record first to get primary key
        let new_record = oauth_providers::ActiveModel {
            provider_name: Set(provider.to_string()),
            client_id: Set(client_id.to_string()),
            client_secret: Set(String::new()), // temporary placeholder
            // Do not persist redirect_url; it's computed at runtime from Config.api_url
            auth_url: Set(final_auth_url.map(|s| s.to_string())),
            token_url: Set(final_token_url.map(|s| s.to_string())),
            userinfo_url: Set(final_userinfo_url.map(|s| s.to_string())),
            created_at: Set(Some(Utc::now().into())),
            updated_at: Set(Some(Utc::now().into())),
            ..Default::default()
        };

        let inserted = new_record
            .insert(db)
            .await
            .map_err(|e| AuthError::internal_error(format!("Failed to insert provider: {}", e)))?;

        let record_id = inserted.id;
        let secret_name = format!("mycorner/oauth/{}/{}", provider, record_id);

        // Create secret in Secrets Manager with unique ID-based name
        if let Err(e) = sm_client.put_secret(&secret_name, client_secret).await {
            // Cleanup: delete the DB record we just created since secret creation failed
            let _ = oauth_providers::Entity::delete_by_id(record_id)
                .exec(db)
                .await;
            return Err(e);
        }

        // Update DB record with the secret name
        let mut am: oauth_providers::ActiveModel = inserted.into();
        am.client_secret = Set(secret_name);
        let final_record = am.update(db).await.map_err(|e| {
            AuthError::internal_error(format!("Failed to update provider with secret name: {}", e))
        })?;

        Ok(final_record)
    }
}

// Secrets manager helper removed; using cloud-agnostic `secrets_manager` instead.
